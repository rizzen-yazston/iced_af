= {iced} Application Framework
Rizzen Yazston
:iced-url: https://crates.io/crates/iced
:iced_aw-url: https://crates.io/crates/iced_aw
:i18n-url: https://crates.io/crates/i18n-rizzen-yazston
:icu-url: https://crates.io/crates/icu
:icu4x-url: https://icu4x.unicode.org/
:iced: pass:q[*iced*]

Welcome to the iced Application Framework project.

The goal is to provide a starting application framework for developing native multi-window {iced} applications.

This project uses the {iced-url}[{iced}] library crates (including {iced_aw-url}[*iced_aw*] community crate for additional widgets) for the GUI of the application.

In addition, the framework supports internationalisation by using the crate {i18n-url}[*i18n-rizzen-yazston*] and various crates of the {icu4x-url}[*ICU4X*] project, the main crate being {icu-url}[*icu*].

== Features

The following features are available:

* log: To enable logging for the application, and inserts a log level setting in Preferences,

* sync: To use `sync::Arc` instead of `rc::Rc`.

== What is included

The application framework has the following capabilities:

* First time launch of application, prompt for user interface language (currently using language tags while waiting for display name feature to be completed in ICU4X),

* The following windows:

** `ConfirmExit`: for demonstration purposes application is set to displayed when exiting (faking unsaved data),

** `Preferences`: contains the user interface language setting, and optional log level setting,

** `FatalError`: for displaying fatal error messages to users (helpful when not launched from console),

** `Information`: a simply generic window to display a message to user,

** `Main`: simply contains a menu bar,

** planned to add an About window.

* Parent windows are generally disabled while popup window is displayed,

* Traps the window decoration close button, to handle certain state cases,

* Windows are resizable and movable, their final position and size is saved on application termination and restored when application is relaunched.

* Supports handling of error `Result`s internally of the `update()` method and the 'Application::new()' method.

== Usage

As this project is a starting point for developing {iced} applications, it can be compiled into a functional example, and be launched by using the application name `example`.

Before launching the `example` copy the `l10n` directory to where the directory where the binary resides to avoid a panic indicating missing localisation database.

== Notes

* The major version number will always match the major version number of {iced} being used.

* Once the `menu` feature of *iced_aw* crate is ready, the framework will be updated.

* Formatting of error message for localisation is still to be implemented.

* This still work in progress, thus the windows may look a bit wonky. Currently focused on functionality than appearances.

* Currently works with `master` branch of {iced} using commit `61e3d85`.

== Design process

Currently just a copy from {iced}'s' Discord server discussion. Still to be cleaned up.

i will add the design principles once iced is released as 0.12.0, which will bring some stability to iced_af.

the i18n library almost all the methods uses the Result type to be able to provide runtime errors that are catchable, where the developer of the application (or another library) can decide to ignore the error, display the error, or leave it uncaught to become a fatal error. this is intentional, thus i inserted a try_update() method within the update() and if an uncaught error reaches this point, simply display the FatalError window, which displays the error message (handy when application is not launched from console) , also prints to console (if used), and if logging is enabled to write to the log.

you will notice there is no try_view() method in view(), this is due to that no errors must occur within view(). to overcome this issue of obtaining localisation strings, that may produce errors, especially if identifiers are missing, the localisation strings are retrieved at the time of the window state is created (as the new() method also includes the try_new() method, and errors are caught to be displayed with FatalError window), or during the update() method.

A note about FatalError, which is a special case, it will not produce fatal errors as a result of missing identifiers, or any other i18n error. it will then use the few built-in english strings and using the Debug and/or Display traits of types to be able to display the error on GUI, console, and to log if available.
you will notice the multi-window example (which I started with) the windows was all the same. originally i used a field to specify the window type, to determine which content to display. yet the view() started becoming unyielding large with the match statement, thus decided to break up the view() into window specific view()s, but still had to maintain the basic match. same went with the try_update(). to resolve this i introduced the WindowType and WindowTrait (along with the AnyWindowTrait to be able to downcast from Any), and the resulting primary application view() became a simple generic method, that was capable of displaying any window type, or number of the same window. not currently seen in iced_af is multi of the same window, that is simply done by using enum variant including an integer (such as usize) or a String to identifier which window to display. the logic of determining which one will be in the logic of the window type's view().

a note on the messages being sent by the windows, or components of the windows, such as can be seen with Main window, it is important to include the window::Id in the message enum variant, when ever you are going to manipulate the iced window state, such as closing the window. once iced_aw has been updated, it will become more clear how to build windows from components, where each component would be in it's own file, containing their own Message, view() and try_update(). i believe the view, message, update, state, etc of a large component should always be kept together for easier maintenance of the code base, and using more generic methods at the core/parent methods to call the children. currently i am using a simple hack to create a "menu bar". menu of iced_aw is my next task to tackle, as it is a complex beast, with plenty breaking changes coming lately from iced that affects it. like to get menu done by the time iced 0.12.0 is released.
